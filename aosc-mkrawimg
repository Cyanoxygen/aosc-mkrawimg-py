#!/usr/bin/env python3

VERSION = ('0', '1', '0')
AUTHORS = ['Cyanoxygen <cyanoxygen@aosc.io>']
LICENSE = 'GPLv3'
REPO = ''

FARGS = [
    ['-v', '--verbose', 'Enable debug output', 'store_true', False],
    ['-f', '--osfile', 'Specify an AOSC OS tarball',
        'store', 'aosc-os_base_arm64_latest.tar.xz', str],
    ['-d', '--workdir', 'Specify the work directory', 'store', '/var/cache/mkrawimg', str],
    ['-l', '--logfile', 'Specify where to place the log file', 'store', 'mkrawimg.log', str],
    ['-m', '--mntprefix', 'Specify the prefix path of mount points', 'store', '/mnt/mkrawimg', str],
    ['-U', '--noupdate', 'Skip the upgrade process after OS extraction', 'store_true', False],
    ['-C', '--nocleanup', 'Skip cleaning up the working directory', 'store_true', False],
    ['-R', '--norecreate', 'Skip the image creation, use the previously created image', 'store_true', False],
]

import yaml
import logging
import subprocess
import argparse
import os
import sys

# Enforce root user execution
if os.getuid() != 0:
    print("Please run me as root, thanks. Exiting.", file=sys.stderr)
    exit(1)

# Get current directory

PWD = os.path.abspath('.')

#
#   Logging configuration
#
# This section configures the logging module, sets up a logger with two outputs. One is the logfile, and the other is the console output.

LOGGER_FORMAT = '%(asctime)-23s | %(levelname)-8s | %(message)s'
logformatter = logging.Formatter(fmt=LOGGER_FORMAT)
consolehandler = logging.StreamHandler(sys.stdout)
consolehandler.setFormatter(logformatter)
logger = logging.getLogger('makeimg')
logger.setLevel('INFO')
logger.addHandler(consolehandler)
info = logger.info
debug = logger.debug
error = logger.error
warn = logger.warn

#
#   Argparse configuration
#
# This section defines command line arguments user can specify.
parser = argparse.ArgumentParser(
    prog=sys.argv[0],
    description='An utility to geneate ready-to-flash AOSC OS images.',
    epilog=f'(C) {", ".join(AUTHORS)}. This program is licensed under {LICENSE}. For more information please refer to {REPO}.'
    )
for arg in FARGS:
    if len(arg) > 5:
        parser.add_argument(arg[0], arg[1], help=arg[2],
                            action=arg[3], default=arg[4], type=arg[5])
    else:
        parser.add_argument(arg[0], arg[1], help=arg[2],
                            action=arg[3], default=arg[4])
parser.add_argument('device', help='Target device to make an image for')
args = parser.parse_args()

#
#   The configuration class
#
class AppConfig:
    '''
    Holds the default app configuration, and loads config.yml.
    This class holds the `general' section of config.yml.
    '''
    class _OSConfig:
        '''
        This class holds os-install section of config.yml.
        '''
        def __init__(self):
            self.lang : str = str(os.environ['LANG']) if 'LANG' in os.environ else 'en_US.UTF-8'
            self.timezone : str = 'Asia/Shanghai'
            self.hostname : str = 'aosc-:variantname'
            self.createuser : bool = True
            self.username : str = 'aosc'
            self.password : str = 'anthon'
            self.fullname : str = 'AOSC OS Built-In User'
            self.group : str = 'audio,video,tty,wheel,adm'
            self.nopasswd : bool = True
            self.method : str = 'tarball'
            self.bootstrap : list = ['base']
        def __format__(self, format_spec: str) -> str:
            return ''

    def __init__(self):
        self.workdir : str = '/var/cache/aosc-mkrawimg'
        self.mntprefix : str = '/mnt/mkrawimg'
        self.logfile : str = 'mkrawimg.log'
        self.noupgrade : bool = False
        self.nocleanup : bool = False
        self.norecreate : bool = False
        self.verbose : bool = False
        self.osfile : str = None

        self.OSConfig = self._OSConfig()

    def loadFromFile(self):
        '''
        Load a config.yml file.
        '''
        confname = os.path.abspath('./config.yml')
        if not os.path.isfile(confname):
            warn('Unable to find config.yml. Using default configuration.')
            return

        try:
            conffile = open(confname, 'r')
        except OSError as e:
            warn(f'Unable to open config.yml: {e.errno} {e.strerror}.') 
            warn('Using default configuration.')
            return
        except Exception as e:
            warn(f'Unable to open config.yml: {e}. Using default configuration.')
            return
        conf = yaml.safe_load(conffile)

        # This is the real magic
        for key in conf['general']:
            self.__setattr__(key, conf['general'][key])
        # load OSConfig in the same way
        for key in conf['os-install']:
            self.OSConfig.__setattr__(key, conf['os-install'][key])
    
    def loadFromArgs(self):
        # This is the real magic, again
        for key in args.__dict__:
            self.__setattr__(key, args.__dict__[key])

#
#   Device class
#
class Device:
    def __init__(self):
        '''
        Loads a default value of all possible options.
        '''

def main():
    global Config
    info(f'Welcome to aosc-mkrawimg v{".".join(VERSION)}!')
    info('Reading config file.')
    Config = AppConfig()
    Config.loadFromFile()
    Config.loadFromArgs()
    '''
    Switch to debug as soon as we can, if either command line or config has enabled it.
    Now the config is loaded and the command line options are parsed,
    we really need to do this now.
    For debug purpose.
    '''
    if args.verbose or Config.verbose:
        logger.setLevel(logging.DEBUG)
        debug('DEBUG output enabled!')
        debug('Now your console output could be really messy ^o^')
    debug('Loading command options...')
    for key in args.__dict__:
        debug(f'{key:<12}: {str(args.__dict__[key]):<}')
    debug('Loaded config:')
    for key in Config.__dict__:
        debug(f'{key:<12}: {Config.__dict__[key]:<}')
    for key in Config.OSConfig.__dict__:
        debug(f'{key:<12}: {str(Config.OSConfig.__dict__[key]):<}')


if __name__ == '__main__':
    main()
